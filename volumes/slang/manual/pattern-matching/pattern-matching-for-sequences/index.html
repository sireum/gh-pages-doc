<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Sequences (anything built from the IS Scala library classes) can be pattern-matched using the class name (constructor) (e.g., ISZ) as illustrated in the example below.
// Patterns in declarations - sequences val seq1 = ISZ(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;) var ISZ(str1,_,str3) = seq1 assert(str1 == &amp;#34;a&amp;#34; &amp;amp;&amp;amp; str3 == &amp;#34;c&amp;#34;) // match case - basic sequence matching @pure def matchSeq(seq: ISZ[Z]): Option[Z] = { seq match { // pattern match on sequence seq case ISZ(n1, n2, n3) =&amp;gt; return Some(n1 &#43; n2 &#43; n3) case ISZ(n1, n2) =&amp;gt; return Some(n1 &#43; n2) case ISZ(n1) =&amp;gt; return Some(n1) case ISZ() =&amp;gt; return Some(0) case _ =&amp;gt; return None() } } assert(matchSeq(ISZ(4,5,6)) == Some(15)) assert(matchSeq(ISZ()) == Some(0)) assert(matchSeq(ISZ(4,5,6,7)) == None[Z]()) // need to give element type for None to make Slang type-checker happy The following example illustrates nested matching for sequence containing tuples." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://doc.sireum.org/volumes/slang/manual/pattern-matching/pattern-matching-for-sequences/" />


    <title>
        
            Pattern Matching for Sequences :: Sireum Doc 
        
    </title>



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/themes/default/style.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/themes/default-dark/style.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://doc.sireum.org/_pagefind/pagefind-ui.css">




<link rel="stylesheet" href="https://doc.sireum.org/main.0d78507e5a16d851bccbdc8be6fca41d9f760aed2c730cd7dcc2200ab3b8fc00.css" integrity="sha256-DXhQfloW2FG8y9yL5vykHZ92Cu0scwzX3MIgCrO4/AA=">



    <link rel="apple-touch-icon" sizes="180x180" href="https://doc.sireum.org/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://doc.sireum.org/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://doc.sireum.org/favicon-16x16.png">
    <link rel="manifest" href="https://doc.sireum.org/site.webmanifest">
    <link rel="mask-icon" href="https://doc.sireum.org/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://doc.sireum.org/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="Pattern Matching for Sequences">
<meta itemprop="description" content="Sequences (anything built from the IS Scala library classes) can be pattern-matched using the class name (constructor) (e.g., ISZ) as illustrated in the example below.
// Patterns in declarations - sequences val seq1 = ISZ(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;) var ISZ(str1,_,str3) = seq1 assert(str1 == &#34;a&#34; &amp;&amp; str3 == &#34;c&#34;) // match case - basic sequence matching @pure def matchSeq(seq: ISZ[Z]): Option[Z] = { seq match { // pattern match on sequence seq case ISZ(n1, n2, n3) =&gt; return Some(n1 &#43; n2 &#43; n3) case ISZ(n1, n2) =&gt; return Some(n1 &#43; n2) case ISZ(n1) =&gt; return Some(n1) case ISZ() =&gt; return Some(0) case _ =&gt; return None() } } assert(matchSeq(ISZ(4,5,6)) == Some(15)) assert(matchSeq(ISZ()) == Some(0)) assert(matchSeq(ISZ(4,5,6,7)) == None[Z]()) // need to give element type for None to make Slang type-checker happy The following example illustrates nested matching for sequence containing tuples."><meta itemprop="datePublished" content="2022-07-27T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-07-27T00:00:00+00:00" />
<meta itemprop="wordCount" content="544"><meta itemprop="image" content="https://doc.sireum.org"/>
<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://doc.sireum.org"/>

<meta name="twitter:title" content="Pattern Matching for Sequences"/>
<meta name="twitter:description" content="Sequences (anything built from the IS Scala library classes) can be pattern-matched using the class name (constructor) (e.g., ISZ) as illustrated in the example below.
// Patterns in declarations - sequences val seq1 = ISZ(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;) var ISZ(str1,_,str3) = seq1 assert(str1 == &#34;a&#34; &amp;&amp; str3 == &#34;c&#34;) // match case - basic sequence matching @pure def matchSeq(seq: ISZ[Z]): Option[Z] = { seq match { // pattern match on sequence seq case ISZ(n1, n2, n3) =&gt; return Some(n1 &#43; n2 &#43; n3) case ISZ(n1, n2) =&gt; return Some(n1 &#43; n2) case ISZ(n1) =&gt; return Some(n1) case ISZ() =&gt; return Some(0) case _ =&gt; return None() } } assert(matchSeq(ISZ(4,5,6)) == Some(15)) assert(matchSeq(ISZ()) == Some(0)) assert(matchSeq(ISZ(4,5,6,7)) == None[Z]()) // need to give element type for None to make Slang type-checker happy The following example illustrates nested matching for sequence containing tuples."/>







    <meta property="article:published_time" content="2022-07-27 00:00:00 &#43;0000 UTC" />










    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="menu-trigger">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
        </svg>
    </span>
    <span class="header__inner">
        <a href="https://doc.sireum.org/" style="text-decoration: none;">
    <div class="logo">
        
            <img class="color-scheme" src="https://doc.sireum.org/img/santos/icon-doc.png" alt="">
            &nbsp;<span class="logo__text">Doc</span>
        
    </div>
</a>


        <span class="header__right">
            
                

<nav class="menu">
  <ul class="menu__inner">
  
  
    
      <div class="submenu">
        <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
          <a class="dropbtn" href="https://doc.sireum.org/volumes/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Volumes&nbsp;<small>ᐁ</small></span>
            <span class="responsive-title-short">Volumes&nbsp;<small>ᐁ</small></span>
          </a>
          <div class="dropdown-content" align="left">
            <ul style="margin:8px;">
              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/slang/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Slang</span>
            <span class="responsive-title-short">Slang</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/hamr/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">HAMR</span>
            <span class="responsive-title-short">HAMR</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/logika" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Logika</span>
            <span class="responsive-title-short">Logika</span>
          </a>
        </li>
      </div>
    
  

              
            </ul>
          </div>
        </li>
      </div>
    
  

  
  
    
      <div class="submenu">
        <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
          <a class="dropbtn" href="https://doc.sireum.org/venues/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Venues&nbsp;<small>ᐁ</small></span>
            <span class="responsive-title-short">Venues&nbsp;<small>ᐁ</small></span>
          </a>
          <div class="dropdown-content" align="left">
            <ul style="margin:8px;">
              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/venues/tutorials/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Tutorials</span>
            <span class="responsive-title-short">Tutorials</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/venues/presentations/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Presentations</span>
            <span class="responsive-title-short">Presentations</span>
          </a>
        </li>
      </div>
    
  

              
            </ul>
          </div>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/getting-started/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Download</span>
            <span class="responsive-title-short">Download</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/papers" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Papers</span>
            <span class="responsive-title-short">Papers</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/funding" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Funding</span>
            <span class="responsive-title-short">Funding</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/team" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Team</span>
            <span class="responsive-title-short">Team</span>
          </a>
        </li>
      </div>
    
  

  </ul>
</nav>

            
        </span>
    </span>
        <span class="theme-toggle not-selectable" style="margin-right: 10px"><img src="https://doc.sireum.org/img/toggle.png" height="20px"></span>
      <div class="submenu">
          <li class="dropdown" onmouseover="menuDisplay(this.children[1], true); searchFocus();" onmouseout="menuDisplay(this.children[1], false);">
              <a class="dropbtn fa fa-search"></a>
              <div class="dropdown-content" align="left">
                  <div id="search" style="z-index:2147483647; position: fixed;"></div>
              </div>
          </li>
      </div>
    
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://doc.sireum.org/volumes/slang/manual/pattern-matching/pattern-matching-for-sequences/">Pattern Matching for Sequences</a></h2>

            
            
            

            <div class="post-content">
                <p>Sequences (anything built from the <code>IS</code> Scala library classes) can be pattern-matched using the class name (constructor) (e.g., <code>ISZ</code>) as illustrated in the example below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Scala" data-lang="Scala"><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   <span class="c1">// Patterns in declarations - sequences
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">val</span> <span class="n">seq1</span> <span class="k">=</span> <span class="nc">ISZ</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">var</span> <span class="nc">ISZ</span><span class="o">(</span><span class="n">str1</span><span class="o">,</span><span class="k">_</span><span class="o">,</span><span class="n">str3</span><span class="o">)</span> <span class="k">=</span> <span class="n">seq1</span>
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="s">&#34;a&#34;</span> <span class="o">&amp;&amp;</span> <span class="n">str3</span> <span class="o">==</span> <span class="s">&#34;c&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// match case - basic sequence matching
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="nd">@pure</span> <span class="k">def</span> <span class="n">matchSeq</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">ISZ</span><span class="o">[</span><span class="kt">Z</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">seq</span> <span class="k">match</span> <span class="o">{</span> <span class="c1">// pattern match on sequence seq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">case</span> <span class="nc">ISZ</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">+</span> <span class="n">n3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nc">ISZ</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nc">ISZ</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nc">ISZ</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nc">None</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">   <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="o">(</span><span class="n">matchSeq</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">))</span> <span class="o">==</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">15</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="o">(</span><span class="n">matchSeq</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">())</span> <span class="o">==</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="o">(</span><span class="n">matchSeq</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">))</span> <span class="o">==</span> <span class="nc">None</span><span class="o">[</span><span class="kt">Z</span><span class="o">]())</span>    <span class="c1">// need to give element type for None to make Slang type-checker happy
</span></span></span></code></pre></div><p>The following example illustrates nested matching for sequence containing tuples.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Scala" data-lang="Scala"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// match case - nested matching on sequences
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="nd">@pure</span> <span class="k">def</span> <span class="n">matchSeqNested</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">ISZ</span><span class="o">[(</span><span class="kt">String</span>,<span class="kt">String</span><span class="o">)])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">seq</span> <span class="k">match</span> <span class="o">{</span> <span class="c1">// pattern match on sequence of pairs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">case</span> <span class="nc">ISZ</span><span class="o">((</span><span class="s">&#34;a&#34;</span><span class="o">,</span><span class="k">_</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span><span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">T</span>      <span class="c1">// matching tuples in sequences (nesting patterns)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">F</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">   <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="o">(</span><span class="n">matchSeqNested</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">((</span><span class="s">&#34;a&#34;</span><span class="o">,</span><span class="s">&#34;HHH&#34;</span><span class="o">),(</span><span class="s">&#34;a&#34;</span><span class="o">,</span><span class="s">&#34;JJJ&#34;</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="o">(!</span><span class="n">matchSeqNested</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">((</span><span class="s">&#34;b&#34;</span><span class="o">,</span><span class="s">&#34;KKK&#34;</span><span class="o">))))</span>
</span></span></code></pre></div><p>Patterns for Slang sequences (<code>IS</code> and <code>MS</code>) can use the <a href="https://www.scala-lang.org/files/archive/spec/2.13/08-pattern-matching.html#pattern-sequences">Scala sequence wildcard</a> <code>_*</code> which matches 0 or more elements of a sequence.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Scala" data-lang="Scala"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// match case - sequence wildcards  _*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="nd">@pure</span> <span class="k">def</span> <span class="n">matchSeqWildcard</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">ISZ</span><span class="o">[</span><span class="kt">Z</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">seq</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nc">ISZ</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">T</span>          <span class="c1">// sequence wildcard _* matches 0 or more elements of a sequence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="c1">// case ISZ(hd, tl @ _*) =&gt; return T  // ERROR: naming _* via pattern binding NOT SUPPORTED IN SLANG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">F</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">   <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="o">(</span><span class="n">matchSeqWildcard</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">)))</span>  <span class="c1">// _* matches 4,3,2,1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">assert</span><span class="o">(</span><span class="n">matchSeqWildcard</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">)))</span>        <span class="c1">// _* matches 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">assert</span><span class="o">(</span><span class="n">matchSeqWildcard</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">(</span><span class="mi">5</span><span class="o">)))</span>          <span class="c1">// _* matches 0 elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">assert</span><span class="o">(!</span><span class="n">matchSeqWildcard</span><span class="o">(</span><span class="nc">ISZ</span><span class="o">()))</span>
</span></span></code></pre></div><p>One might hope to take advantage of the <em>pattern binding</em> concept to name the &ldquo;tail&rdquo; of the sequence in the example above.  The <a href="https://www.scala-lang.org/files/archive/spec/2.13/08-pattern-matching.html#pattern-sequences">grammar for Scala pattern sequences</a> indicates that this is accepted in Scala, <em>but it is not supported in Slang</em>.</p>
<h2 id="scala-connection">Scala Connection</h2>
<p>Slang pattern matching on sequences is similar to Scala&rsquo;s (see, for example, <a href="https://riptutorial.com/scala/example/3056/pattern-matching-on-a-seq">this tutorial</a>).</p>
<p>Sequence pattern matching in both Scala and Slang is based on the fact that Scala allows pattern matching using constructors of non-case classes as long as the class defines an <code>unapply</code> or <code>unapplySeq</code> methods (these are called &ldquo;extractor patterns&rdquo; see <a href="https://www.scala-lang.org/files/archive/spec/2.13/08-pattern-matching.html#extractor-patterns">Scala documentation for pattern matching</a>).  This is the strategy used to realize pattern matching for the <code>IS</code> family of Slang types, since <code>IS</code> is a Slang library class that is not a case class (similarly for <code>MS</code>).</p>
<p>However, Slang&rsquo;s pattern matching is limited to matching on the primary constructor (e.g., <code>ISZ(...)</code>) and, in contrast to Scala, does not support matching on infix operations such as <code>+:</code>, <code>::</code>, or <code>:+</code>.   This means that one cannot use Slang pattern matching to break a sequence apart into named head and tail (e.g., <code>hd +: tl</code>) (as one might want to do when using sequences in a manner similar to cons-based lists in a functional language).  Retreiving a named Slang sequence head
can be accomplished using the sequence wildcard (e.g., <code>ISZ(hd, _*)</code>).  To enable pattern matching with the sequence wildcard, Scala classes must implement the <code>unapplySeq</code> method, and Slang <code>IS</code> and <code>MS</code> supports this.</p>
<!-- notice note ShortCode -->
<p><strong>JH: To Robby, check the description above &hellip;</strong>.</p>
<!-- notice end ShortCode -->
            </div>
        </article>

        <hr />

        
<div style="display: grid; grid-template-columns: 2% 49% 49%; text-align: center;">
  <div class="submenu" style="background: transparent; text-align: left; position: relative;">
    <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
      <a class="dropbtn" href=""><i class="fa-solid fa-angles-up"></i></a>
      <div class="dropdown-content" style="bottom: 100%;"><a class="post-item-inner" href="https://doc.sireum.org/volumes/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Volumes</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/slang/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Slang</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/slang/manual/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Reference Manual</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/slang/manual/pattern-matching/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Pattern Matching</a></div>
    </li>
  </div>
  <div style="text-align: left;">
    
      <a href="https://doc.sireum.org/volumes/slang/manual/pattern-matching/pattern-matching-for-option-types/" style="text-decoration: none;" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
        <i class="fa-solid fa-chevron-left"></i> Pattern Matching for Option Types
      </a>
    
  </div>
  <div style="text-align: right;">
    
      <a href="https://doc.sireum.org/volumes/slang/manual/pattern-matching/pattern-matching-for-sets/" style="text-decoration: none;" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Pattern Matching for Sets
        <i class="fa-solid fa-chevron-right"></i>
      </a>
    
  </div>
</div>



        <div class="post-info">
            
            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin="anonymous"></script>



<script type="text/javascript" src="https://doc.sireum.org/bundle.min.d9847dec188cb3ba71e262769d7f64069d223c3a9713999a5da5f7aca5638686e15a900ac07cc755d19861961f24145ef2d608296933e4150cae87f4911a7dbb.js" integrity="sha512-2YR97BiMs7px4mJ2nX9kBp0iPDqXE5maXaX3rKVjhobhWpAKwHzHVdGYYZYfJBRe8tYIKWkz5BUMrof0kRp9uw=="></script>


<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/thecarnie-cycle2/2.1.6c/jquery.cycle2.min.js" integrity="sha512-ydWfQuPu+srw5hhkU8O1XGn3/Kc+GyoDBvYc8E+SyuZKphQP18ZWYKywIFzPWZwQk6dlmTY69aDg/SnFz3qPeQ==" crossorigin="anonymous"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/js/all.min.js" integrity="sha512-rpLlll167T5LJHwp0waJCh3ZRf7pO6IT1+LZOhAyP6phAirwchClbTZV3iqL3BMrVxIYRbzGTpli4rfxsCK6Vw==" crossorigin="anonymous"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/jstree.min.js" integrity="sha512-OQ2by9SrJBwcXaeYmkG2t6FVZiwpyRtFar2VvULjuq5OjVpJLwsUHuNzN9PClqEJAYsWsRPSb4TTfriZzPGiow==" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://doc.sireum.org/_pagefind/pagefind-ui.js"></script>
  <script type="text/javascript">
    window.addEventListener('DOMContentLoaded', (event) => {
      new PagefindUI({
        element: "#search",
        showEmptyFilters: true,
        mergeIndex: [
          
            { bundlePath: "https:\/\/sireum.org\/_pagefind" },
          
            { bundlePath: "https:\/\/slang.sireum.org\/_pagefind" },
          
            { bundlePath: "https:\/\/logika.sireum.org\/_pagefind" },
          
        ]
      });
    });
  </script>
<script style="text/javascript">
  window.addEventListener('load', function () {
    $('#page-tree').jstree({
      "core": {
        "themes": {
          "name": document.documentElement.getAttribute("data-theme") == "dark" ? "default-dark" : "default",
          "dots": true,
          "icons": false,
          "variant": "large"
        }
      },
      plugins: [ "ui" ],
    }).bind("select_node.jstree", function (e, data) {
      document.location.href = data.node.a_attr.href;
    }).bind("ready.jstree", function (event, data) {
      $(this).jstree("open_all");
    }).bind("open_all.jstree", function (event, data) {
      level = 0;
      data.instance.element.find('li').each(function() {
        if (level > 0 && data.instance.get_path(this).length >= level){
          data.instance.close_node(this);
        }
      });
      data.instance.element.get()[0].style.display="block";
    });
  });
</script>


    </body>
</html>
