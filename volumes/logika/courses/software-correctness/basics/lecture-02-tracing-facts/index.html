<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Tracing Values Execution as Value Calculation A common way to reason about a program is to trace its execution and try to determine the values of variables at different in the execution. The simplest approach that students follow when learning to program is to add some &amp;ldquo;print&amp;rdquo; statements in their code to print out the values of variables at certain points. Later, one learns how to use a debugger, which can show the current values of variables without having to add explicit &amp;ldquo;print&amp;rdquo; statements." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics/lecture-02-tracing-facts/" />


    <title>
        
            Lecture Summary: Tracing Facts :: Sireum Doc 
        
    </title>



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/themes/default/style.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/themes/default-dark/style.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://doc.sireum.org/_pagefind/pagefind-ui.css">




<link rel="stylesheet" href="https://doc.sireum.org/main.9b7fec326fab4b320f3a6ebff5b2cd1a56f40af9971ff15a0213c97eff1ce5d0.css" integrity="sha256-m3/sMm&#43;rSzIPOm6/9bLNGlb0CvmXH/FaAhPJfv8c5dA=">



    <link rel="apple-touch-icon" sizes="180x180" href="https://doc.sireum.org/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://doc.sireum.org/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://doc.sireum.org/favicon-16x16.png">
    <link rel="manifest" href="https://doc.sireum.org/site.webmanifest">
    <link rel="mask-icon" href="https://doc.sireum.org/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://doc.sireum.org/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="Lecture Summary: Tracing Facts">
<meta itemprop="description" content="Tracing Values Execution as Value Calculation A common way to reason about a program is to trace its execution and try to determine the values of variables at different in the execution. The simplest approach that students follow when learning to program is to add some &ldquo;print&rdquo; statements in their code to print out the values of variables at certain points. Later, one learns how to use a debugger, which can show the current values of variables without having to add explicit &ldquo;print&rdquo; statements."><meta itemprop="datePublished" content="2022-11-24T17:01:09+01:00" />
<meta itemprop="dateModified" content="2022-11-24T17:01:09+01:00" />
<meta itemprop="wordCount" content="5496"><meta itemprop="image" content="https://doc.sireum.org"/>
<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://doc.sireum.org"/>

<meta name="twitter:title" content="Lecture Summary: Tracing Facts"/>
<meta name="twitter:description" content="Tracing Values Execution as Value Calculation A common way to reason about a program is to trace its execution and try to determine the values of variables at different in the execution. The simplest approach that students follow when learning to program is to add some &ldquo;print&rdquo; statements in their code to print out the values of variables at certain points. Later, one learns how to use a debugger, which can show the current values of variables without having to add explicit &ldquo;print&rdquo; statements."/>







    <meta property="article:published_time" content="2022-11-24 17:01:09 &#43;0100 &#43;0100" />










    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="menu-trigger">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
        </svg>
    </span>
    <span class="header__inner">
        <a href="https://doc.sireum.org/" style="text-decoration: none;">
    <div class="logo">
        
            <img class="color-scheme" src="https://doc.sireum.org/img/santos/icon-doc.png" alt="">
            &nbsp;<span class="logo__text">Doc</span>
        
    </div>
</a>


        <span class="header__right">
            
                

<nav class="menu">
  <ul class="menu__inner">
  
  
    
      <div class="submenu">
        <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
          <a class="dropbtn" href="https://doc.sireum.org/volumes/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Volumes&nbsp;<small>ᐁ</small></span>
            <span class="responsive-title-short">Volumes&nbsp;<small>ᐁ</small></span>
          </a>
          <div class="dropdown-content" align="left">
            <ul style="margin:8px;">
              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/slang/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Slang</span>
            <span class="responsive-title-short">Slang</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/hamr/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">HAMR</span>
            <span class="responsive-title-short">HAMR</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/logika" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Logika</span>
            <span class="responsive-title-short">Logika</span>
          </a>
        </li>
      </div>
    
  

              
            </ul>
          </div>
        </li>
      </div>
    
  

  
  
    
      <div class="submenu">
        <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
          <a class="dropbtn" href="https://doc.sireum.org/venues/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Venues&nbsp;<small>ᐁ</small></span>
            <span class="responsive-title-short">Venues&nbsp;<small>ᐁ</small></span>
          </a>
          <div class="dropdown-content" align="left">
            <ul style="margin:8px;">
              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/venues/tutorials/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Tutorials</span>
            <span class="responsive-title-short">Tutorials</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/venues/presentations/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Presentations</span>
            <span class="responsive-title-short">Presentations</span>
          </a>
        </li>
      </div>
    
  

              
            </ul>
          </div>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/getting-started/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Download</span>
            <span class="responsive-title-short">Download</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/papers" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Papers</span>
            <span class="responsive-title-short">Papers</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/funding" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Funding</span>
            <span class="responsive-title-short">Funding</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/team" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Team</span>
            <span class="responsive-title-short">Team</span>
          </a>
        </li>
      </div>
    
  

  </ul>
</nav>

            
        </span>
    </span>
        <span class="theme-toggle not-selectable" style="margin-right: 10px"><img src="https://doc.sireum.org/img/toggle.png" height="20px"></span>
      <div class="submenu">
          <li class="dropdown" onmouseover="menuDisplay(this.children[1], true); searchFocus();" onmouseout="menuDisplay(this.children[1], false);">
              <a class="dropbtn fa fa-search"></a>
              <div class="dropdown-content" align="left">
                  <div id="search" style="z-index:2147483647; position: fixed;"></div>
              </div>
          </li>
      </div>
    
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics/lecture-02-tracing-facts/">Lecture Summary: Tracing Facts</a></h2>

            
            
            
                <hr />
                <aside id="toc">
                <div class="toc-title">Table of Contents</div>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#tracing-values">Tracing Values</a>
      <ul>
        <li><a href="#execution-as-value-calculation">Execution as Value Calculation</a></li>
        <li><a href="#example-experimenting-with-the-program-via-testing">Example: Experimenting with the Program via Testing</a></li>
        <li><a href="#limitations-of-tracing-values-only">Limitations of Tracing Values Only</a></li>
      </ul>
    </li>
    <li><a href="#tracing-facts">Tracing Facts</a>
      <ul>
        <li><a href="#example-deducing-facts-for-immutable-variables">Example: Deducing Facts for Immutable Variables</a></li>
      </ul>
    </li>
    <li><a href="#tracing-facts-with-logika">Tracing Facts with Logika</a>
      <ul>
        <li><a href="#logika">Logika</a></li>
      </ul>
    </li>
    <li><a href="#tracing-facts-for-mutable-variables">Tracing Facts for Mutable Variables</a>
      <ul>
        <li><a href="#reasoning-about-mutable-variables-using-logical-variable-versions">Reasoning about Mutable Variables using Logical Variable &ldquo;Versions&rdquo;</a></li>
        <li><a href="#a-notational-simplification-for-the-most-recent-version-of-a-variable">A Notational Simplification for the &ldquo;Most Recent&rdquo; Version of a Variable&quot;</a></li>
      </ul>
    </li>
    <li><a href="#analysing-programs">Analysing Programs</a></li>
    <li><a href="#test-case-derivation">Test Case Derivation</a></li>
    <li><a href="#a-deeper-dive-symbolic-execution">A Deeper Dive: Symbolic Execution</a></li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
                </aside>
                <hr />
            

            <div class="post-content">
                <h3 id="tracing-values">Tracing Values</h3>
<h4 id="execution-as-value-calculation">Execution as Value Calculation</h4>
<p>A common way to reason about a program is to trace its execution and try to determine the values of variables at different in the execution.  The simplest approach that students follow when learning to program is to add some &ldquo;print&rdquo; statements in their code to print out the values of variables at certain points.  Later, one learns how to use a debugger, which can show the current values of variables without having to add explicit &ldquo;print&rdquo; statements.  Once we become experienced programmers, we often use a debugger, but it is second-nature for us to look at code and predict the possible values of variables at specific points.   When looking for program errors, we often imagine the &ldquo;correct&rdquo; or &ldquo;desired&rdquo; or &ldquo;expected&rdquo; values of variables and then look for possible deviations (e.g., with &ldquo;print&rdquo; statements or with the debugger).  In other words, we calculate &ldquo;in our heads&rdquo; expected values and compare them to those produced by program execution.   We can follow a similar approach directly without executing a program: we can state expected values by asserting them and compare them to those produced by mental calculations.</p>
<p>Looking at a series of examples will help us tie together some basic relationships between our natural intuitions, automated program verification, and testing.  Consider the simple straightline code below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
</span></span></code></pre></div><p>This code fragment initialises variable <code>m</code> to <code>3</code> and variable <code>n</code> to <code>5</code>.  We use an assertion at the end of the program
to claim that variable <code>x</code> equals <code>5</code> and variable <code>y</code> equals <code>3</code>.</p>
<p>We now construct a &ldquo;mental trace&rdquo; of the program to see if our claim holds.<br>
We state in interspersed comments the variable values that we  <strong>deduce</strong> (calculate &ldquo;in our heads&rdquo;), e.g., using comments like the following..</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// deduce v == e &amp; w == f &amp; ...
</span></span></span></code></pre></div><p>&hellip;which indicate that we deduced variable <code>v</code> has value <code>e</code>, and so on.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// deduce m == 3
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// deduce m == 3 &amp; n == 5
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// deduce m == 3 &amp; n == 5 &amp; z == 8
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">//   ...because we calculate that 3 (value of m) + 5 (value of n) == 8
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// deduce m == 3 &amp; n == 5 &amp; z == 8 &amp; y == 3
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">//   ...because we calculate that 8 (value of z) - 5 (value of n) == 3
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// deduce m == 3 &amp; n == 5 &amp; z == 8 &amp; y == 3 &amp; x == 5
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">//   ...because we calculate that 8 (value of z) - 3 (value of y) == 5
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
</span></span></code></pre></div><p>In this example, since all variables are assigned only once,
we can focus our attention on the value of each &ldquo;new&rdquo; variable because each previously assigned variable retains its same value.</p>
<p>The calculation right before the assertion yields <code>y == 3 &amp; x == 5</code>, i.e., the calculation confirms the expected values stated in the assertion.</p>
<h4 id="example-experimenting-with-the-program-via-testing">Example: Experimenting with the Program via Testing</h4>
<p>Instead of tracing variable values in our head, we design an <em>experiment</em> on the code with a testing framework, and then use a debugger to launch the experiment and observe the variable values as the execution proceeds (see Appendices XXX and YYY for suggestions for setting up your code, tests, and running the debugger).</p>
<p><img src="../images/basics-ex1-debugger.png" alt="ex1-debugger"></p>
<p>The screenshot above shows the IntelliJ IDE: we have placed our example code above in a Slang function <code>ex1</code> (top editor pane) and then written a test method in the ScalaTest framework that will execute <code>ex1</code> (bottom editor pane).  Adding a break point at line 9 and then launching the test using the IntelliJ debugger allows us to use the debugger to step line-by-line through the <code>ex1</code> code.  The debugger view at the bottom of the screen shows the current values of variables defined up to the current point in the execution, and the code itself is annotated to show the values of the two most-recently assigned variables.  Note how closely this matches our manually added deduce comments in the example above.   Of course, this is to be expected because years of experience with building debuggers has led tool providers to design the debugging facilities to align with how developers naturally think about and interact with their programs!</p>
<p>Here are some key points that we would like to emphasize about how testing supplements our manual reasoning about programs.</p>
<ul>
<li>When we execute a test, we <em>perform an experiment on the program</em> and then we <em>make observations about its behavior</em>.</li>
<li>Ideally, we have <em>one or more hypotheses about the behavior that we expect to observe</em>.  Often our hypotheses are indicated as expected results in a test.  In the example above, we can think of the assertion as specifying our hypothesis or our desired outcome for the experiment.</li>
<li>Each test/experiment will lead to a <em>single execution trace</em> of the code.  When we use a debugger in combination with the test, the debugger helps us make intermediate observations about the trace (e.g., values of variables) as the trace unfolds.</li>
</ul>
<h4 id="limitations-of-tracing-values-only">Limitations of Tracing Values Only</h4>
<p>The code above is extremely easy for us to reason about because it gives rise to a single trace.  Therefore,</p>
<ul>
<li>we were able to determine a specific value for each variable at each point in the program</li>
<li>we were able to completely explore (&ldquo;cover&rdquo;) the code&rsquo;s behavior with a single experiment (test)</li>
</ul>
<p>What if we don&rsquo;t know the initial values of variables <code>m</code> and <code>n</code>?  In Slang, one way to express this is by writing using the <code>randomInt()</code> function.  Function <code>randomInt()</code> specifies that an arbitrary integer value is chosen by the underlying runtime system.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span></code></pre></div><p>Now consider how you would reason about a variation of the original code that uses <code>randomInt()</code> for the initial values of <code>m</code> and <code>n</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><ul>
<li>What should you record in comments for the values of <code>m</code> and <code>n</code>?</li>
<li>What should you record in comments for the values of <code>z</code> and <code>y</code>?</li>
<li>When you consider the specific values that might get assigned to <code>m</code> and <code>n</code>, how many executions traces are possible for this code?</li>
</ul>
<p>Trying to answer the questions above leads to the following conclusions:</p>
<ul>
<li>for all practical purposes, there are an unlimited number of possible values for the program variables in the code above, so trying to determine the complete meaning of the code by reasoning only in terms of concrete values is infeasible.</li>
<li>for all practical purposes, there are an unlimited number of traces for the code.</li>
</ul>
<p>While we can often get valuable intuition by looking at examples with specific values and specific traces, that is not enough for us to reason about the complete meaning of the program nor ensure that it is free from error.</p>
<p>(ToDo: Experimenting with a program with a test and a debugger only covers one execution trace at a time.  We have a potentially infinite number of traces).</p>
<h3 id="tracing-facts">Tracing Facts</h3>
<p>To addressing the limitations outlined above, we need to expand the concept of tracking <strong>specific values</strong> of variables to tracking <strong>facts</strong> (i.e., constraints or properties about all the possible values that a variable might take on during any
possile execution).  We can still handle situations where we happen to know the specific value of a variable:
a specific variable value is just a special kind of fact that constrains a variable to one value.</p>
<p>Let&rsquo;s consider this example in more detail.</p>
<h4 id="example-deducing-facts-for-immutable-variables">Example: Deducing Facts for Immutable Variables</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><p>There&rsquo;s nothing to deduce from the first two assignments except that <code>m</code> and <code>n</code> have arbitrary values.
The first &ldquo;interesting&rdquo; fact that we can deduce follows the assignment to <code>z</code>.
After this assignment <code>z</code> must equal <code>m + n</code>.
We deduce <code>z == m + n</code> corresponding directly to the assignment <code>z = m + n</code>.
Let&rsquo;s insert a comment introducing this fact.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// deduce z == m + n
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><p>We can see immediately that there is such a fact immediately deducible from each assignment statement.
Let&rsquo;s add those and label them as <code>statement facts: assignment</code>.  In subsequent chapters, we will see
how each category of program statement gives rise to a specific form of statement facts.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// deduce z == m + n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1">// deduce y == z - n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1">// deduce x == z - y    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><p>Note that deduced information immediately above the asserion is not enough deduce <code>x == n</code> and <code>y == m</code>.
There are some additional principles that we need to incorporate.</p>
<p><strong>Propagating previously deduced facts</strong>:  In many situations in our code, facts deduced at early points in the program can be &ldquo;carried along&rdquo; and brought to the current code point that we are reasoning about.  Our example code block is designed to emphasize a particular code style where we can always carry previously deduced facts forward, i.e., situations where we are not updating (re-assigning to variables) but only introducing new variable names.  Because each &ldquo;variable&rdquo; is our example is assigned only once (emphasized by their <code>val</code> declarations), we can bring &ldquo;old facts&rdquo; about those variables forward.
Observe that we can record facts about the variable <code>z</code> (e.g., <code>z == m + n</code>) after the assignments to <code>y</code> and <code>x</code> even though
<code>z</code> is assigned <em>before</em> <code>y</code> and <code>x</code>.
We can bring the fact <code>z == m + n</code> to points later in the code because the fact still holds
(nothing has interferred with the values of <code>z</code>, <code>m</code>, or <code>n</code> in the mean time).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// deduce z == m + n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced and still valid fact)
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// deduce y == z - n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced and still valid fact)
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// deduce y == z - n    (previously deduced and still valid fact)
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// deduce x == z - y    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><p>Having explained how previously deduced facts can be carried along when they remain valid, from now on we will
abbreviate our annotations for such facts and simply say <code>(previously deduced fact)</code> with the implicit qualification
that they still remain valid.</p>
<p><strong>Use computational principles (i.e., the &ldquo;theory&rdquo;) of the data types of our variables</strong>:  Even though we are not tracking concrete values, we can often predict how our program will compute common operations like addition and subtraction on numberic values, taking the head or tail of a list, etc.   In the case of integers, such reasoning often amounts to applying principles that we learned in algebra.  Then we add additional reasoning properties for equality and &ldquo;substitution of equals for equals&rdquo;.</p>
<p>For example, consider what we can do with the two facts <code>z == m + n</code> and <code>y == z - n</code> right after the assignment to <code>y</code>:</p>
<ul>
<li>We can deduce  <code>y == (m + n) - n</code> from the two facts about because <code>z</code> is equal to <code>m + n</code> &ndash; thus we can &ldquo;replace&rdquo; or &ldquo;substitute&rdquo; <code>m + n</code> for <code>z</code> in the fact <code>y == z - n</code></li>
<li>We can then deduce <code>y == m + (n - n)</code> by using algebraic reasoning to reassociate the subtraction to apply to the references to <code>n</code>.</li>
<li>Then we use the principles (theory) of the subtraction operation to conclude that <code>n - n</code> is equal to <code>0</code></li>
<li>Then we can replace <code>n - n</code> with <code>0</code> to obtain <code>y == m + 0</code></li>
<li>Finally, can deduce <code>y == m</code> immediately after the assignment to <code>y</code> using the algebraic property that <code>0</code> is the identity element for addition.</li>
</ul>
<p>The fact <code>y == m</code> is not affected by the assignment to <code>x</code>, thus we can carry it forward as we do the other facts to obtain
the following.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// deduce z == m + n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// deduce y == z - n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// deduce y == m        (proof via algebra)
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// deduce y == z - n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// deduce y == m        (previously deduced fact)
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// deduce x == z - y    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><p>Now, we can apply the same strategy after the assignment to <code>x</code> to gain some additional facts.
From <code>z == m + n</code> and <code>y == m</code> and <code>x == z - y</code>, we deduce <code>x == (m + n) - y</code>, further <code>x == (m + n) - m</code>,
and further <code>x == (m - m) + n</code>, and <code>x == 0 + n</code>, thus <code>x == n</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// deduce z == m + n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// deduce y == z - n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// deduce y == m        (proof via algebra)
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// deduce y == z - n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// deduce y == m        (previously deduced fact)
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// deduce x == z - y    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// deduce x == n        (proof via algebra)
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><p>Now we can see that we have facts enough to establish that the assertion <em>never</em> fails, regardless of the
random values assigned to <code>m</code> and <code>n</code>.</p>
<p>In summary, facts that we use to demonstrate program correctness come from different sources and principles as indicated above.
Knowledge about the program is gathered and increased by inferring new facts.</p>
<p>We have generalised the approach of tracing values in programs to tracing facts.
This has permitted us to demonstrate program correctness <strong>independently</strong> of variables&rsquo; initial values.
Without much difficulty we have attained a much more powerful method to verify programs.</p>
<p>We expect that the steps that we have applied could also be carried out <strong>automatically</strong>.  For reasoning about the example above, the automation could record our knowledge about the program in several different ways, and it could
proceed with the reasoning in a different order.<br>
For example, at each assignment, the automation could alternatively just obtain new facts that are immediate consequences of the current assignment and carry over previously deduced facts (i.e., it could omit deducing fact using algebra).
Then, it could lazily only perform the reasoning based on algebra, substitution, etc. when there is some need for it in the program, for example, when we need to establish that an assertion is correct.   The code below expresses that strategy using our comment notation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// deduce z == m + n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// deduce y == z - n    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// deduce z == m + n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// deduce y == z - n    (previously deduced fact)
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// deduce x == z - y    (statement fact: assignment)
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// deduce y == m        (proof via algebra)
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// deduce x == n        (proof via algebra)
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></div><p>This later approach, which can be summarized as &ldquo;accumulate syntactically obvious facts, but perform more complicated deductions only when needed&rdquo; is the strategy that Logika and many other automated verifiers use.</p>
<h3 id="tracing-facts-with-logika">Tracing Facts with Logika</h3>
<h4 id="logika">Logika</h4>
<p><img src="../images/Logika-immutable-1.png" alt="Logika-Immutable-1"></p>
<p><img src="../images/Logika-immutable-2.png" alt="Logika-Immutable-2"></p>
<p><img src="../images/Logika-immutable-3.png" alt="Logika-Immutable-3"></p>
<p><img src="../images/Logika-immutable-4.png" alt="Logika-Immutable-4"></p>
<p><img src="../images/Logika-immutable-5.png" alt="Logika-Immutable-5"></p>
<p><img src="../images/Logika-immutable-6.png" alt="Logika-Immutable-6"></p>
<p><img src="../images/Logika-immutable-7-check-assertion.png" alt="Logika-Immutable-7"></p>
<h3 id="tracing-facts-for-mutable-variables">Tracing Facts for Mutable Variables</h3>
<p>So far, we have reasoned about programs with <strong>immutable</strong> variables that are only assigned a value once.
This was helpful</p>
<ul>
<li>to learn about how facts propagate though programs</li>
<li>to get a first impression of Logika</li>
</ul>
<p>Next, we consider <strong>mutable</strong> variables that can be assigned a new value repeatedly.
As a consequence, we need to distinguish <strong>old</strong> values from <strong>new</strong> values for the <strong>same</strong> variable.</p>
<p>Let&rsquo;s rewite the code example from above to use mutable variables.
Note that this code has the effect of swapping the values of variables <code>x</code> and <code>y</code> &ldquo;in place&rdquo;, i.e.,
without using an intermediate variable as we often do when swapping.</p>
<p>Mutable variables are declared with the keyword <code>var</code> instead of <code>val</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this program <code>x</code> is assigned three times and <code>y</code> two times.
Let&rsquo;s try our reasoning method from the last section that we applied for immutable variables and see what goes wrong.</p>
<ul>
<li>After the first assignment to <code>x</code> we would obtain the fact <code>x == m</code></li>
<li>After the second assignment to <code>x</code> we would obtain the fact <code>x == x + y</code></li>
<li>This is not right!</li>
<li>The second assignment refers to the old value of <code>x</code> on the right-hand side, relating to the fact <code>x == m</code></li>
<li>The left-hand side of that assignment refers to the new value</li>
</ul>
<h4 id="reasoning-about-mutable-variables-using-logical-variable-versions">Reasoning about Mutable Variables using Logical Variable &ldquo;Versions&rdquo;</h4>
<p>Over the years, the formal methods community has used several general notational strategies for tackling the variable
&ldquo;old value vs new value&rdquo; issue.
To understand Logika&rsquo;s approach, note that when a program has mutable variables,
from a logical view there are multiple &ldquo;versions&rdquo; of a mutable variables &ndash;
whenever we (re)assign a to a mutable variable, we are logically creating a new version.</p>
<p>To emphasize the &ldquo;multiple versions&rdquo; view and the specific way that Logika notates variable versions,
let&rsquo;s label the mutable variable versions according to the order in which they are assigned looking backwards
from the final assertion <code>x == n &amp; y == m</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span>   <span class="c1">// 0 - 0th version of x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">n</span>   <span class="c1">// 0 - 0th version of y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>      <span class="c1">// 1 - 1st version of x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>      <span class="c1">// 1 - 1st version of y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>      <span class="c1">// 2 - 2nd version of y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can refer to the <em>n</em>&rsquo;th version of a variable $v$ by means of the expression <code>At(v, n)</code>.
Now we apply our previous reasoning and commenting approach, and incorporate this notation for variable versions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m     (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">n</span>  <span class="c1">// 0 
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m     (previously deduced and still valid fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 0) == n     (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>     <span class="c1">// 1   
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m                    (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 0) == n                    (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 1) == At(x, 0) + At(y, 0)  (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>     <span class="c1">// 1  
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m                    (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 0) == n                    (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 1) == At(x, 0) + At(y, 0)  (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 1) == At(x, 1) - At(y, 0)  (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>     <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m                    (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 0) == n                    (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 1) == At(x, 0) + At(y, 0)  (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 1) == At(x, 1) - At(y, 0)  (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 2) == At(x, 1) - At(y, 1)  (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 1) == m                    (proof via algebra)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 2) == n                    (proof via algebra)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The problem of &ldquo;new value&rdquo; vs &ldquo;old value&rdquo; has disappeared.
In essence, the notation for variable versions gives a unique name for every logical value that a variable might have.
Since this is analogous to the way that <code>val</code> variables give us a unique name for each assignment to a variable (i.e.,
there is only one assignment),  we can reason about the program as before.
We just apply the &ldquo;variable version&rdquo; notation to any point in a program,
replacing variables with references to versions up to that point.</p>
<h4 id="a-notational-simplification-for-the-most-recent-version-of-a-variable">A Notational Simplification for the &ldquo;Most Recent&rdquo; Version of a Variable&quot;</h4>
<p>To make the contraints at a program point easier to read, Logika
refers to the &ldquo;most recent version&rdquo; of a variable by simply listing the variable without a specific version notation.
Using this simplified notation, the comments reflecting our reasoning are listed below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce x == m                          (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">n</span>  <span class="c1">// 0 
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce x == m                          (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce y == n                          (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>     <span class="c1">// 1   
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m                   (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce y == n                          (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce x == At(x, 0) + y               (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>     <span class="c1">// 1  
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m                   (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 0) == n                   (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce x == At(x, 0) + At(y, 0)        (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce y == x - At(y, 0)               (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>     <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 0) == m                   (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(y, 0) == n                   (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce At(x, 1) == At(x, 0) + At(y, 0) (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce y == At(x, 1) - At(y, 0)        (previously deduced fact)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce x == At(x, 1) - y               (statement fact: assignment)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce y == m                          (proof via algebra)
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce n == n                          (proof via algebra)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="analysing-programs">Analysing Programs</h3>
<p>In the presentation above, we have seen that a program&rsquo;s (or block of code&rsquo;s) meaning can be described logically as a collection of facts.  Each line of a program <code>P</code> gives rise to one or more facts, and the meaning of the entire program can be given as the conjunction <strong>P<sub>fact</sub></strong> of those facts.</p>
<p>We now take a look ahead and give some intuition about how viewing a program&rsquo;s meaning as a collection of facts can provide a basis for multiple types of automated analyses and exploration of a program&rsquo;s behavior.</p>
<p>Later on, we will introduce a number of different forms of contracts and specifications that enable the developer to express correctness objectives about a program.   For now, we can just build on the idea of an assertion as expressing developer correctness goals.
Each assertion, e.g., <code>assert(x == n &amp; y == m)</code> corresponds to a fact <code>a</code>, namely, <code>x == n &amp; y == m</code>.
We can combine the assertion fact <code>a</code> with the program facts <strong>P<sub>fact</sub></strong> in different logical structures to analyze a program in different ways.</p>
<p>Here are three ways in which we can use <strong>P<sub>fact</sub></strong> to analyse program <code>P</code>.</p>
<ul>
<li>
<p>Using <strong>P<sub>fact</sub></strong> <code>|- a</code> (i.e., assume <strong>P<sub>fact</sub></strong> holds and try to show that <code>a</code> holds), we can <strong>prove</strong> that assertion <code>a</code> is true for all executions of <code>P</code>.  This is essentially how Logika verifies assertions.</p>
</li>
<li>
<p>Using <strong>P<sub>fact</sub></strong> <code>&amp; a</code>, we can search for values for which <code>a</code> is true.
This is the basis for generating <strong>tests</strong> that confirm that <code>a</code> holds (note that in our little example program,
we have to remove assignments from <code>randomInt()</code> first).</p>
</li>
<li>
<p>Using <strong>P<sub>fact</sub></strong> <code>&amp; !a</code>, we can search for values for which <code>a</code> is false.
This yields <strong>counterexamples</strong>, i.e., specific values for the variables of <code>P</code> that violate <code>a</code>.
If no such value can be found among all possible values of all variables, then <strong>P<sub>fact</sub></strong> <code>|- a</code> must be true.
This technique is the basis of (bounded) <strong>model checking</strong>.</p>
</li>
</ul>
<h3 id="test-case-derivation">Test Case Derivation</h3>
<p>We will study test generation principles in detail later, but for now we can gain some intution about the relationship between
systematic test design and program facts with the following examples.</p>
<p>First, let&rsquo;s recall the code for swapping two integers with a concluding assertion specifying the goal of the code.
We add an <code>assume</code> statement at the beginning of the code block to control the scope of the analysis by limiting the ranges
of the variables <code>m</code> and <code>n</code>.   Logically, this has the following interpretation:<br>
Assuming the condition <code>m &gt; 0 &amp; y &gt; 0</code> is true initially, the condition <code>x == n &amp; y == m</code> must be true finally.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">assume</span><span class="o">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Applying the  <strong>P<sub>fact</sub></strong> <code>&amp; a</code> structure from above for deriving a confirming test, we get the following
conjunction of facts.</p>
<!-- These two should be next to eachother -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>                   <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="n">m</span>                   <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="nc">At</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="n">n</span>                   <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="nc">At</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="nc">At</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>        <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">y</span>               <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>To find a confirming test case, we search for values of input parameters <code>m</code> and <code>n</code> that make the conjunction above true.
<code>m == 1</code> and <code>n == 2</code> is one scenario that makes the conjunction true, as shown by substituting <code>1</code> for <code>m</code> and <code>2</code> for <code>n</code>
then simplifying below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span>                   <span class="o">&amp;</span>    <span class="c1">// (substituting for m and n)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span>                   <span class="o">&amp;</span>    <span class="c1">// (substituting for m)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nc">At</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span>                   <span class="o">&amp;</span>    <span class="c1">// (substituting for n)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="nc">At</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="nc">At</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>        <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">y</span>               <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span>                      <span class="c1">// (substituting for n and m)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In this scenario, we can see that <code>At(x, 0) == 1</code> and <code>At(y, 0) == 2</code> so we can substitue <code>1</code> for <code>At(x, 0)</code> and <code>2</code> for <code>At(y, 0)</code>
to obtain</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span>                   <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>                          <span class="o">&amp;</span>    <span class="c1">// (substituting for At(x,0))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>                          <span class="o">&amp;</span>    <span class="c1">// (substituting for At(y,0))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>               <span class="o">&amp;</span>    <span class="c1">// (substituting for At(x,0) and At(y,0))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">2</span>               <span class="o">&amp;</span>    <span class="c1">// (substituting for At(y,0))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="o">==</span> <span class="nc">At</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">y</span>               <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span>                      
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now see that <code>At(x, 1) == 1 + 2 == 3</code> so we can substitue <code>3</code> for <code>At(x, 1)</code>
to obtain</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span>                   <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>                          <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>                          <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>                      <span class="o">&amp;</span>    <span class="c1">// (substituting for At(x,1))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span>                      <span class="o">&amp;</span>    <span class="c1">// (substituting for At(x,1))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">y</span>                      <span class="o">&amp;</span>    <span class="c1">// (substituting for At(x,1))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span>                      
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now, we see that <code>y == 3 - 2 == 1</code> which then gives us <code>x == 3 - y == 2</code> so we can substitute &lsquo;1&rsquo; for &lsquo;y&rsquo; and &lsquo;2&rsquo; for &lsquo;x&rsquo; to obtain</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span>                   <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>                          <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>                          <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>                      <span class="o">&amp;</span>    
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span>                      <span class="o">&amp;</span>    <span class="c1">// (substituting for y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">2</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>                      <span class="o">&amp;</span>    <span class="c1">// (substituting for x, y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>                      <span class="c1">// (substituting for x, y)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Which confirms that the constraints are satisfied for the scenario where <code>m == 1</code> and <code>n == 2</code></p>
<h3 id="a-deeper-dive-symbolic-execution">A Deeper Dive: Symbolic Execution</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">assume</span><span class="o">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There&rsquo;s yet another way we can reason about this program.
We execute the program abstractly with <strong>symbolic values</strong> and <strong>path conditions</strong>.
Symbolic values record the modifications of the variables.
Path conditions record the conditions that must be true to reach locations in the program.
We record symbolic values in the tuple (<code>m</code>, <code>n</code>, <code>x</code>, <code>y</code>) and the path condition as (PC:&hellip;).
Let&rsquo;s do this with the value swapping example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">assume</span><span class="o">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Executing <code>assume(m &gt; 0 &amp; n &gt; 0)</code> yields (<code>m: M, n: N</code>), (PC: <code>M &gt; 0 &amp; N &gt; 0</code>)</li>
<li>Executing <code>var x: Z = m</code> yields (<code>m: M, n: N, x: M</code>), (PC: <code>M &gt; 0 &amp; N &gt; 0</code>)</li>
<li>Executing <code>var y: Z = n</code> yields (<code>m: M, n: N, x: M, y: N</code>), (PC:<code> M &gt; 0 &amp; N &gt; 0</code>)</li>
<li>Executing <code>x = x + y</code> yields (<code>m: M, n: N, x: M + N, y: N</code>), (PC: <code>M &gt; 0 &amp; N &gt; 0</code>)</li>
<li>Executing <code>y = x - y</code> yields (<code>m: M, n: N, x: M + N, y: M</code>), (PC: <code>M &gt; 0 &amp; N &gt; 0</code>)</li>
<li>Executing <code>x = x - y</code> yields (<code>m: M, n: N, x: N, y: M</code>), (PC: <code>M &gt; 0 &amp; N &gt; 0</code>)</li>
<li>Executing <code>assert(x == n &amp; y == m)</code> yields</li>
<li>(<code>m: M, n: N, x: N, y: M</code>), (PC: <code>M &gt; 0 &amp; N &gt; 0, N == N &amp; M == M</code>)</li>
</ul>
<p>The expression <code>M + N</code> cannot be further simplified at this stage because <code>M</code> and <code>N</code> are uninterpreted symbolic constants.</p>
<h3 id="summary">Summary</h3>
<p>We have looked at various ways of reasoning about programs:</p>
<ul>
<li>by tracing variable values through programs &ndash; giving us specific traces that correspond to a test, which can be seen as a single &ldquo;experiment&rdquo; on the program&rsquo;s behavior,</li>
<li>by tracing facts through a program &ndash; allowing us to reason about all possible traces through a program with a single analysis,</li>
<li>by considering a program as a conjunction of facts that can be manipulated in several ways</li>
<li>by symbolic execution</li>
</ul>
<p>We have seen how these approaches can be used to reason in different ways about programs:</p>
<ul>
<li>to prove assertions</li>
<li>to find counterexamples</li>
<li>to generate tests</li>
</ul>
<p>We will discuss this continually during the course as the programs become more and more challenging.</p>

            </div>
        </article>

        <hr />

        
<div style="display: grid; grid-template-columns: 2% 49% 49%; text-align: center;">
  <div class="submenu" style="background: transparent; text-align: left; position: relative;">
    <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
      <a class="dropbtn" href=""><i class="fa-solid fa-angles-up"></i></a>
      <div class="dropdown-content" style="bottom: 100%;"><a class="post-item-inner" href="https://doc.sireum.org/volumes/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Volumes</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Logika</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/courses/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Course Materials</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/courses/software-correctness/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Logika Course: Software Correctness</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Basic Principles</a></div>
    </li>
  </div>
  <div style="text-align: left;">
    
  </div>
  <div style="text-align: right;">
    
      <a href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics/simple-informal/" style="text-decoration: none;" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Informal Reasoning about Simple Programs
        <i class="fa-solid fa-chevron-right"></i>
      </a>
    
  </div>
</div>



        <div class="post-info">
            
            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin="anonymous"></script>



<script type="text/javascript" src="https://doc.sireum.org/bundle.min.d9847dec188cb3ba71e262769d7f64069d223c3a9713999a5da5f7aca5638686e15a900ac07cc755d19861961f24145ef2d608296933e4150cae87f4911a7dbb.js" integrity="sha512-2YR97BiMs7px4mJ2nX9kBp0iPDqXE5maXaX3rKVjhobhWpAKwHzHVdGYYZYfJBRe8tYIKWkz5BUMrof0kRp9uw=="></script>


<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/thecarnie-cycle2/2.1.6c/jquery.cycle2.min.js" integrity="sha512-ydWfQuPu+srw5hhkU8O1XGn3/Kc+GyoDBvYc8E+SyuZKphQP18ZWYKywIFzPWZwQk6dlmTY69aDg/SnFz3qPeQ==" crossorigin="anonymous"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/js/all.min.js" integrity="sha512-rpLlll167T5LJHwp0waJCh3ZRf7pO6IT1+LZOhAyP6phAirwchClbTZV3iqL3BMrVxIYRbzGTpli4rfxsCK6Vw==" crossorigin="anonymous"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/jstree.min.js" integrity="sha512-OQ2by9SrJBwcXaeYmkG2t6FVZiwpyRtFar2VvULjuq5OjVpJLwsUHuNzN9PClqEJAYsWsRPSb4TTfriZzPGiow==" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://doc.sireum.org/_pagefind/pagefind-ui.js"></script>
  <script type="text/javascript">
    window.addEventListener('DOMContentLoaded', (event) => {
      new PagefindUI({
        element: "#search",
        showEmptyFilters: true,
        mergeIndex: [
          
            { bundlePath: "https:\/\/sireum.org\/_pagefind" },
          
            { bundlePath: "https:\/\/slang.sireum.org\/_pagefind" },
          
            { bundlePath: "https:\/\/logika.sireum.org\/_pagefind" },
          
        ]
      });
    });
  </script>
<script style="text/javascript">
  window.addEventListener('load', function () {
    $('#page-tree').jstree({
      "core": {
        "themes": {
          "name": document.documentElement.getAttribute("data-theme") == "dark" ? "default-dark" : "default",
          "dots": true,
          "icons": false,
          "variant": "large"
        }
      },
      plugins: [ "ui" ],
    }).bind("select_node.jstree", function (e, data) {
      document.location.href = data.node.a_attr.href;
    }).bind("ready.jstree", function (event, data) {
      $(this).jstree("open_all");
    }).bind("open_all.jstree", function (event, data) {
      level = 0;
      data.instance.element.find('li').each(function() {
        if (level > 0 && data.instance.get_path(this).length >= level){
          data.instance.close_node(this);
        }
      });
      data.instance.element.get()[0].style.display="block";
    });
  });
</script>


    </body>
</html>
