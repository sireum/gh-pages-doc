<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Logika - The Basic Automated Deduction Process We have approached the faulty fragment by a method of program debugging: We have stated which result we expected and then traced values of variables occuring during the execution of the fragment until we have found the error, e.g, the erroneous assigment to variable y. Note, that we have traced values forwards following the sequence of assigments but that have stated the expected values backwards starting from the result." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics-old/motivation-logika/" />


    <title>
        
            Motivation Logika :: Sireum Doc 
        
    </title>



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/themes/default/style.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/themes/default-dark/style.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://doc.sireum.org/_pagefind/pagefind-ui.css">




<link rel="stylesheet" href="https://doc.sireum.org/main.9b7fec326fab4b320f3a6ebff5b2cd1a56f40af9971ff15a0213c97eff1ce5d0.css" integrity="sha256-m3/sMm&#43;rSzIPOm6/9bLNGlb0CvmXH/FaAhPJfv8c5dA=">



    <link rel="apple-touch-icon" sizes="180x180" href="https://doc.sireum.org/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://doc.sireum.org/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://doc.sireum.org/favicon-16x16.png">
    <link rel="manifest" href="https://doc.sireum.org/site.webmanifest">
    <link rel="mask-icon" href="https://doc.sireum.org/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://doc.sireum.org/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="Motivation Logika">
<meta itemprop="description" content="Logika - The Basic Automated Deduction Process We have approached the faulty fragment by a method of program debugging: We have stated which result we expected and then traced values of variables occuring during the execution of the fragment until we have found the error, e.g, the erroneous assigment to variable y. Note, that we have traced values forwards following the sequence of assigments but that have stated the expected values backwards starting from the result."><meta itemprop="datePublished" content="2022-07-20T15:42:11+02:00" />
<meta itemprop="dateModified" content="2022-07-20T15:42:11+02:00" />
<meta itemprop="wordCount" content="3026"><meta itemprop="image" content="https://doc.sireum.org"/>
<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://doc.sireum.org"/>

<meta name="twitter:title" content="Motivation Logika"/>
<meta name="twitter:description" content="Logika - The Basic Automated Deduction Process We have approached the faulty fragment by a method of program debugging: We have stated which result we expected and then traced values of variables occuring during the execution of the fragment until we have found the error, e.g, the erroneous assigment to variable y. Note, that we have traced values forwards following the sequence of assigments but that have stated the expected values backwards starting from the result."/>







    <meta property="article:published_time" content="2022-07-20 15:42:11 &#43;0200 &#43;0200" />










    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="menu-trigger">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
        </svg>
    </span>
    <span class="header__inner">
        <a href="https://doc.sireum.org/" style="text-decoration: none;">
    <div class="logo">
        
            <img class="color-scheme" src="https://doc.sireum.org/img/santos/icon-doc.png" alt="">
            &nbsp;<span class="logo__text">Doc</span>
        
    </div>
</a>


        <span class="header__right">
            
                

<nav class="menu">
  <ul class="menu__inner">
  
  
    
      <div class="submenu">
        <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
          <a class="dropbtn" href="https://doc.sireum.org/volumes/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Volumes&nbsp;<small>ᐁ</small></span>
            <span class="responsive-title-short">Volumes&nbsp;<small>ᐁ</small></span>
          </a>
          <div class="dropdown-content" align="left">
            <ul style="margin:8px;">
              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/slang/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Slang</span>
            <span class="responsive-title-short">Slang</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/hamr/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">HAMR</span>
            <span class="responsive-title-short">HAMR</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/volumes/logika" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Logika</span>
            <span class="responsive-title-short">Logika</span>
          </a>
        </li>
      </div>
    
  

              
            </ul>
          </div>
        </li>
      </div>
    
  

  
  
    
      <div class="submenu">
        <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
          <a class="dropbtn" href="https://doc.sireum.org/venues/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Venues&nbsp;<small>ᐁ</small></span>
            <span class="responsive-title-short">Venues&nbsp;<small>ᐁ</small></span>
          </a>
          <div class="dropdown-content" align="left">
            <ul style="margin:8px;">
              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/venues/tutorials/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Tutorials</span>
            <span class="responsive-title-short">Tutorials</span>
          </a>
        </li>
      </div>
    
  

              
                
  
  
    
      <div>
        <li>
          <a href="https://doc.sireum.org/venues/presentations/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Presentations</span>
            <span class="responsive-title-short">Presentations</span>
          </a>
        </li>
      </div>
    
  

              
            </ul>
          </div>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/getting-started/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Download</span>
            <span class="responsive-title-short">Download</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/papers" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Papers</span>
            <span class="responsive-title-short">Papers</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/funding" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Funding</span>
            <span class="responsive-title-short">Funding</span>
          </a>
        </li>
      </div>
    
  

  
  
    
      <div>
        <li>
          <a href="https://sireum.org/team" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
            <span class="responsive-title-long">Team</span>
            <span class="responsive-title-short">Team</span>
          </a>
        </li>
      </div>
    
  

  </ul>
</nav>

            
        </span>
    </span>
        <span class="theme-toggle not-selectable" style="margin-right: 10px"><img src="https://doc.sireum.org/img/toggle.png" height="20px"></span>
      <div class="submenu">
          <li class="dropdown" onmouseover="menuDisplay(this.children[1], true); searchFocus();" onmouseout="menuDisplay(this.children[1], false);">
              <a class="dropbtn fa fa-search"></a>
              <div class="dropdown-content" align="left">
                  <div id="search" style="z-index:2147483647; position: fixed;"></div>
              </div>
          </li>
      </div>
    
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics-old/motivation-logika/">Motivation Logika</a></h2>

            
            
            

            <div class="post-content">
                <h3 id="logika---the-basic-automated-deduction-process">Logika - The Basic Automated Deduction Process</h3>
<p>We have approached the faulty fragment by a method of program debugging:
<em>We have stated which result we expected and
then traced values of variables occuring during the execution of the fragment
until we have found the error</em>, e.g, the erroneous assigment to variable <code>y</code>.
Note, that we have traced values forwards following the sequence of assigments
but that have stated the expected values backwards starting from the result.
This is a rather natural way to approach reasoning about programs
as the information about the expected values propagates backwards from the result
and the information about values propagates forward along the executed assignments.</p>
<p>(John: it seems like we should use phrases above like &ldquo;We state our intentions/expectations&rdquo; and also &ldquo;we consider the facts that must be true at/after each statement in the program&rdquo;, and &ldquo;when we try to reason about whether the assertion holds or not, we see if the facts at that point will cause the assertion to be true&rdquo;.)</p>
<ul>
<li>
<p>illustrate tracing of values of variables with light bulbs, and illustrate logika checking of assertions for val-based example.</p>
</li>
<li>
<p>explain what we mean by fact: a condition/expression referencing the value of program variables (which connects more subtely to the language of expressions)</p>
</li>
<li>
<p>explain using lightbulbs the deduce steps in comments.</p>
</li>
</ul>
<h4 id="immediate-fact-accumulation-and-display">Immediate Fact Accumulation and Display</h4>
<p>As Logika processes a code, it collects facts that it discovers by moving forward step-by-step through the code.   Some of the accumulated facts are immediately apparent from the structure of each program statement (we will refer to these as <em>immediate facts</em>).  Others are the result of deductions that it has made by calling the underlying SMT solvers (we will refer to those as <em>deduced facts</em>).  Logika can display the facts that it has accumulated at any point in the program to provide <em>hints</em> about how to systematically reason about the program.  Hints can be viewed by clicking on the lightbulb icon in the IVE editor margin as shown in the figure above.</p>
<p><img src="../images/basics-logika-ex01-hints-02.png" alt="Logika - Example 01 - Hints (a)"></p>
<p>In the figure above, the developer has clicked on the lightbulb at <strong>Line 7</strong>, which causes the IVE to open the window panes on the right to display the accumulated facts at that point in the program.  Logika organizes its information in terms of the <em>pre-state</em> of a statement (the state of execution <em>immediately before</em> a statement) and a <em>post-state</em> (the state of execution <em>immediately after</em> a statement).</p>
<p>At the point immediately before <strong>Line 7</strong>, only the assignment to <code>x</code> at <strong>Line 6</strong> has executed.  Thus, the only accumulated fact in the pre-state of <strong>Line 7</strong> is the immediate fact <code>x == 1</code>.</p>
<p><img src="../images/basics-logika-ex01-hints-01.png" alt="Logika - Example 01 - Hints (b)"></p>
<p>In contrast, clicking on the lightbulb at <strong>Line 6</strong> reveals that Logika has no knowledge about the program&rsquo;s variables, because none have been assigned yet.</p>
<p><img src="../images/basics-logika-ex01-hints-03.png" alt="Logika - Example 01 - Hints (c)"></p>
<p>Clicking on the lightbulb at <strong>Line 8</strong> shows the  facts known in the pre-state of <strong>Line 8</strong>  (i.e., before the assignment to <code>z</code> at <strong>Line 8</strong> and immediately after the assignment to <code>y</code> in <strong>Line 7</strong>).  The facts include both the immediate facts that we have from the assignment to <code>x</code> at <strong>Line 6</strong> as well as the assignment to <code>y</code> at <strong>Line 7</strong>.</p>
<p><img src="../images/basics-logika-ex01-hints-04.png" alt="Logika - Example 01 - Hints (d)"></p>
<p>At <strong>Line 10</strong>, the lightbulb information indicates that Logika has immediate facts from the the assignments to <code>x</code>, <code>y</code>, and <code>z</code>.</p>
<h4 id="deductions-and-smt-interaction">Deductions and SMT Interaction</h4>
<p><img src="../images/basics-logika-ex01-summoning.png" alt="Logika - Example 01 - Summoning"></p>
<p>At <strong>Line 10</strong>, we see two new margin annotations &ndash; a lightning bolt and an error marker.</p>
<p>This indicates that Logika has made an automated deduction (in this case, trying to verify that the assertion holds) that requires interactions with its underlying SMT solvers.  Logika calls these interactions &ldquo;summonings&rdquo; because the power of SMT is being &ldquo;summoned&rdquo; to make a deduction that can&rsquo;t be carried out using simple syntactic manipulation of the  facts that it has accumulated about the program.   Clicking on the lightning bolt shows the details of the summoning.   The most useful information to the developer is the sequent:</p>
<pre tabindex="0"><code>; Sequent:
;
; x === 1,
; y === (x + x) + 1,
; z === x + y
; ⊢
; z == 3
</code></pre><p>Intuitively, Logika is asking the SMT solvers, &ldquo;Assuming the facts <code>x === 1</code>, and <code>y === (x + x) + 1</code> hold, can you prove <code>z === x + y</code>?.
The sequent is a traditional notation from logic that has the following structure:</p>
<pre tabindex="0"><code>&lt;assumption-1&gt; 
 ...
&lt;assumption-n&gt; 
 ⊢
&lt;conclusion&gt;
</code></pre><p>A sequent is a logical claim that, under the assumption that assumptions 1 through n hold, the conclusion can be proved.  Note that the assumptions in a sequent are often called <em>antecedents</em> and the conclusion is often called the <em>consequent</em>.   Logika uses this notation to indicate what &ldquo;question&rdquo; it is asking of the SMT solvers, i.e., it is asking the SMT solvers, does the given sequent hold?</p>
<p>Other information in the Output pane</p>
<pre tabindex="0"><code>; Validity Check for Assertion at [10, 10]
; Result (cached): Invalid
</code></pre><p>indicates the purpose of the summoning (Logika is trying to determine if the assertion expression at Line 10, Column 10 is valid) and the result of the SMT query (the provide sequent, and thus the assertion at Line 10 is invalid).</p>
<p>Logika summoning results can be: Valid, Invalid, Don&rsquo;t Know, or Time Out.   We&rsquo;ll discuss the later two later, but intuively they both indicate that the SMT solver can&rsquo;t determine if the sequent holds or not.</p>
<p>The rest of the information</p>
<pre tabindex="0"><code>(set-logic ALL)

(define-sort B () Bool)
(define-fun |B.unary_!| ((x B)) B (not x))
...
</code></pre><p>is an encoding of Logika&rsquo;s knowledge about the program and the sequent into the standardized SMT2 language of the SMT solvers.  The display of the encoding is meant for tool experts.  We don&rsquo;t explain it here and we don&rsquo;t refer to it in these course notes, but an overview can be found in (XXXXX To be done XXXXXX).</p>
<p><img src="../images/basics-logika-ex04.png" alt="Logika - Example 04 - Program Verified"></p>
<p>If we correct the mistake in the assignment to <code>y</code>, the problem marker disappears and Logika pops up a message in the lower right corner reporting that it has verified our program.   In general, a<br>
report of &ldquo;Logika Verified&rdquo; means that, for all possible executions of the program</p>
<ul>
<li>all assertions hold,</li>
<li>there will never be a run-time error (e.g., a divide-by-zero or an array/sequence out-of-bounds index), and</li>
<li>the computations indicated by the program code satisfy any included Logika contracts.</li>
</ul>
<p>That these results hold <em>for all possible</em> executions is an amazing testimony to power of logic: without any testing (experimentation) on the program, the properties are established by automated deduction alone. <strong>TBD: Expand on this, or eventually connect it to some broader philosophical discussion on knowledge discovering by experimentation vs knowledge discovering by deduction.</strong></p>
<h4 id="deducing-facts-expressed-as-assertions">Deducing Facts Expressed as Assertions</h4>
<p>When we illustrated manual reasoning, we added assertion statements interleaved with our assignment statements, as illustrated below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">assert</span><span class="o">(</span><span class="n">z</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
</span></span></code></pre></div><p>The assertions stated various facts that we believed to be the consequence of execution to that point.  In our mental reasoning, this gave us confidence that the execution was proceeding according to our intent, and we inferred that the execution resulted in additional properties such as <code>y == 2</code> and <code>y == 3</code> that were not immediately captured in the program text.</p>
<p>There are several methodologies that we can follow with Logika to reason about the execution at intermediate program points and to confirm at those points that our expectations about the execution are met.</p>
<p>The first approach is simply to let Logika process the interleaved assertions as in the code above.  It&rsquo;s good to understand this option, so we will start with it.  Later we&rsquo;ll consider another approach that is more flexible and that doesn&rsquo;t unnecessarily add executable assertions to our generated code.</p>
<p><img src="../images/basics-logika-ex03-assertion-holds.png" alt="Logika - Example 03 - Assertion Holds"></p>
<p>The absence of error markers in the figure above illustrates that Logika verified our code.   The <code>assert(y == 2)</code> at <strong>Line 10</strong> is the first place where Logika had to prove a claim that wasn&rsquo;t immediately apparent from the code text.   Clicking on the lightning bolt at <strong>Line 10</strong> shows the sequent used to prove the claim:  the antecedents of the sequent include accumulated immediate facts, and the consequent is the expression that must be true for Logika to verify the assertion.</p>
<p>Just as we gathered confidence from the result of interleaved assertions in our manual reasoning, Logika will add the deduced fact <code>y == 2</code> to its accumulated facts as it continues to the next line in the program.</p>
<p><img src="../images/basics-logika-ex03-deduced-fact.png" alt="Logika - Example 03 - Assertion Holds"></p>
<p>The figure above shows the accumulated facts in the pre-state of <strong>Line 11</strong>, i.e., the point immediately after <code>assert(y == 2)</code>.  In addition to the immediate facts deduced from the program text, the accumulated facts include the deduced fact <code>y == 2</code>.</p>
<h3 id="discovering-possible-run-time-exceptions">Discovering Possible Run-time Exceptions</h3>
<p>In addition to checking the validity of assertions, Logika checks for possible run-time exceptions (see XXXX for a complete list).</p>
<p><img src="../images/basics-logika-ex05-divide-by-zero-error.png" alt="Logika - Example 03 - Divide by Zero Error"></p>
<p>Logika flags the divide-by-zero show above with a red error marker, and clicking on the marker indicates the error in the <code>Output</code> pane.</p>
<p><img src="../images/basics-logika-ex05-summoning.png" alt="Logika - Example 03 - Assertion Holds"></p>
<p>Clicking on the lightning bolt shows the sequent that Logika uses to try to prove the absence of the run-time exception, i.e., given the facts that have been accumulated so far, can it be proven that divisor argument is non-zero.</p>
<p>** Possible Exercise: load the motivation-09.sc example (which fixes the divide by zero error) and click through margin annotations **.</p>
<h3 id="representing-unknown-values">Representing Unknown Values</h3>
<p>Up to this point, we have only used Logika to examine facts about immutable variables whose values can be completely determined or can be stated in terms of the values of other variables or mathematical expressions.   Often our programs have variables that, at least at some points of the program, we don&rsquo;t know anything about.   From Logika&rsquo;s point of view &ldquo;don&rsquo;t know anything about&rdquo; means that Logika doesn&rsquo;t have any constraints (either immediate facts or derived facts) on the variable.
For example, at the end of the program fragment below,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span></code></pre></div><p>we know something about <code>z</code> (expressed in terms of the values of <code>m</code> and <code>n</code>).  However, we don&rsquo;t know anything about the values of <code>m</code> and <code>n</code>: because their values are random &ndash; they are completely unconstrained.</p>
<p><img src="../images/basics-logika-ex10-random-representation.png" alt="Logika - Random Representation"></p>
<p>Clicking on the lightbulb at <strong>Line 9</strong> shows the facts that Logika knows immediately before the assignment to <code>y</code>.   The facts for <code>m</code> and &rsquo;n&rsquo; illustrate that Logika uses a special marker to represent values returned from its <code>random</code> functions.  For <code>m</code>, the <code>At[Z](&quot;.random&quot;, 0)</code> represents the value returned by the zero&rsquo;th occurence of <code>random</code> within the current program/method, whereas <code>At[Z](&quot;.random&quot;, 1)</code> represents the value returned by the first occurence.  Note that we wouldn&rsquo;t have sufficient information if just used a single marker <code>[Z](&quot;.random&quot;)</code> for all calls to <code>random</code>.   We need to keep track of the fact that the random value generated for <code>m</code> is not the same as the random value generated for <code>n</code>.  Using a single marker would cause Logika to treat the values for <code>m</code> and &lsquo;<code>n</code> as being identical.</p>
<p>These markers are the user-facing representation of just one of several kinds of &ldquo;symbolic values&rdquo; (also called &ldquo;logic variables&rdquo;) that Logika uses for automated program reasoning.   The common concept that each of these different symbolic values share is that they each represent an arbitrary (unconstrained) value to which constraints can be applied.</p>
<h3 id="checking-explicit-deductions-in-logikas-proof-language">Checking Explicit Deductions in Logika&rsquo;s Proof Language</h3>
<p>We previously illustrated how we can manually reason about programs by recording facts about the execution in comments.  Below is a fragment of our previously considered example.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">randomInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="c1">// deduce z == m + n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="c1">// deduce y == z - n
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce y == (m + n) - n
</span></span></span><span class="line"><span class="cl"><span class="c1">// deduce y == m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="o">...</span>
</span></span></code></pre></div><p>Instead of using informal comments, we can record such deductions as checkable claims using Logika&rsquo;s proof language as illustrated below.</p>
<p><img src="../images/basics-logika-ex10-deduce.png" alt="Logika - Deduce"></p>
<p>Between each statement in the code, one can list multiple claims in a <code>Deduce</code> proof clause.   Each claim, e.g., <code>(y == z - n)</code> is followed by a justification, e.g., <code>by Premise</code> indicating why the claim should be true.  While the proof language contains many types of justifications, this example uses only two.</p>
<ul>
<li><code>Premise</code> indicates a claim that is true because (a) it is immediately derivable from the program text without a call to the underlying SMT solvers at the current point, or (b) it has already been explicitly claimed and proved by Logika previously.  In most cases, a claimed justified by <code>Premise</code> will appear in accumulated facts displayed by the lightbulb marker at that particular statement.  For example, the claim <code>(y == z - n)</code> at <strong>Line 20</strong> appears in the facts listed by the lightbulb annotation at <strong>Line 18</strong>.</li>
<li><code>Auto</code> indicates that Logika can prove the claim by automated reasoning with calls to the underlying SMT solvers.</li>
</ul>
<p>A slight variation of the <code>Deduce</code> clauses above further clarifies the principles behind <code>Premise</code> and <code>Auto</code>.</p>
<p><img src="../images/basics-logika-ex10-deduce-subtleties.png" alt="Logika - Deduce"></p>
<p>Switching the justification from <code>Premise</code> to <code>Auto</code> at <strong>Line 10</strong> illustrates that every claim that can be proved using <code>Premise</code> can also be proved using <code>Auto</code>.  In fact, the implementation of <code>Auto</code> will first use the <em>implementation of <code>Premise</code></em> to see if the claim is already in the set of know facts, e.g., as revealed by the light bulb information, before making calls to the SMT solvers to try to prove the claim.</p>
<p>The error marker at <strong>Line 16</strong> illustrates that the reverse does not hold: there are claims proved using SMT deductions via <code>Auto</code> that cannot be proved by <code>Premise</code>.</p>
<p><strong>Line 26</strong> and <strong>Line 27</strong> illustrate that immediate facts also arise from other constructs such as correct assertions (not just assignment statements).   Clicking the light bulb annotation at <strong>Line 26</strong> illustrates how any assertion expression proved to hold by Logika will be added to the known facts (see the last fact in the known facts list).  Thus, a claim corresponding to the assertion expression can be proved by <code>Premise</code> at <strong>Line 27</strong>.</p>
<p><strong>Line 28</strong> illustrates that a claim once proved by <code>Auto</code> (e.g., at <strong>Line 21</strong>) can now be taken as a <code>Premise</code>.   This relates to the displayed known facts (generated from the light bulb at <strong>Line 26</strong>) indicating that the claimed proved at <strong>Line 21</strong> was entered into the list of known facts.</p>
<h3 id="tracking-facts-about-mutable-variables">Tracking Facts about Mutable Variables</h3>
<p>As discussed previously, reasoning about mutable variables is more difficult because a variable may have different values at different points in the program.  Thus, we are typically led to say things like &ldquo;the value of <code>x</code> at this point in the program&rdquo;.  From another point of view, we may consider that there are different &ldquo;versions&rdquo; of the variable &ndash; one version for each time the variable is assigned.  We now illustrate how Logika reflects this intuition as it tracks facts about mutable variables.</p>
<p>The figure below illustrates the known facts at <strong>Line 12</strong> &ndash; <em>after</em> all the variables have been declared (assigned assigned a value once), but <em>before</em> any variables (e.g., <code>x</code> and <code>y</code>) have been updated.</p>
<p><img src="../images/basics-logika-ex11-variable-declarations.png" alt="Logika - Deduce"></p>
<p>At this point in the program, Logika uses a single name for each variable (the declared variable name).
However, the figure below shows that after a variable is updated (e.g., after the update to <code>x</code> at <strong>Line 12</strong>), the notation for variable references changes.  The known facts display at <strong>Line 13</strong> illustrates that Logika uses the notation <code>At(x, 0)</code> to refer to the value associated from the zero&rsquo;th assignment of <code>x</code> at <strong>Line 9</strong> (i.e., the &ldquo;previous&rdquo; value of <code>x</code>) and then uses the &ldquo;regular&rdquo; name <code>x</code> to refer to the <em>most recent assignment</em> to <code>x</code> at <strong>Line 12</strong>.</p>
<p><img src="../images/basics-logika-ex11-old-x.png" alt="Logika - Deduce"></p>
<p>To capture the effect of the assignment to <code>x</code> at <strong>Line 12</strong>, the known facts display at <strong>Line 13</strong> includes the constraint</p>
<pre tabindex="0"><code>x == At(x, 0) + y
</code></pre><p>which indicates that the &ldquo;new&rdquo; value of <code>x</code> (indicated by the direct use of <code>x</code> for the most recent version) is equal to the &ldquo;previous&rdquo; value of <code>x</code> (indicated by <code>At(x, 0)</code> &ndash; the zero&rsquo;th assignment to <code>x</code>) added to the current value of <code>y</code> (the only value, to this point).</p>
<p>Continuing through the program, the known facts immediately before the execution of the assertion at <strong>Line 16</strong> include references to multiple versions of <code>x</code> and <code>y</code>.</p>
<p><img src="../images/basics-logika-ex11-assert-lightbulb.png" alt="Logika - Deduce"></p>
<p>Because we now have an assignment to <code>y</code> at <strong>Line 13</strong> and yet another assign to <code>x</code> at <strong>Line 14</strong>, the constraint presented as</p>
<pre tabindex="0"><code>x == At(x, 0) + y
</code></pre><p>in the known facts display at <strong>Line 13</strong> now is now presented as</p>
<pre tabindex="0"><code>At(x,1) == At(x, 0) + At(y, 0)
</code></pre><p><code>At(x,1)</code> refers to the 1&rsquo;th version of <code>x</code> assigned at <strong>Line 12</strong>,
<code>At(x,0)</code> refers to the 0&rsquo;th version of <code>x</code> assigned at <strong>Line 9</strong>, and
<code>At(y,0)</code> refers to the 0&rsquo;th version of <code>y</code> assigned at <strong>Line 10</strong>.</p>
<p>The constraint</p>
<pre tabindex="0"><code>x == At(x, 1) - y
</code></pre><p>captures the effect of the assignment at <strong>Line 14</strong> where the current value of <code>x</code> is computed from the previous version of <code>x</code> (the 1&rsquo;th version assigned at <strong>Line 12</strong>) and the current version of <code>y</code>.</p>
<p>Note: there are other possible notations that Logika could use to keep track of different versions of variables.  For example, it could use line numbers where variables are assigned to keep track of different versions.   Because we sometimes want to use the <code>At(..,..)</code> notation to reference previous versions of variables in Logika proof blocks, referencing in terms of the &ldquo;0&rsquo;th&rdquo;, &ldquo;1&rsquo;th&rdquo;, etc. assignment is less brittle (less subject to change) when the program is subsequently edited (e.g., lines are inserted or deleted).</p>
<p>In the figure below, the sequent displayed in the summoning for the assertion verification at <strong>Line 16</strong> (viewed by clicking on the light bulb at <strong>Line 16</strong>) illustrates that when Logika sends constraints to the SMT solver, it converts the <code>At(..,..)</code> into variable references based on line numbers.</p>
<p><img src="../images/basics-logika-ex11-assert-bolt.png" alt="Logika - Deduce"></p>
<p>For example, the constraint for the assignment at <strong>Line 12</strong> presented as</p>
<pre tabindex="0"><code>At(x,1) == At(x, 0) + At(y, 0)
</code></pre><p>in the known facts display becomes</p>
<pre tabindex="0"><code>x@12 == x@9 + y@10
</code></pre><p>when passed to the SMT solvers.</p>

            </div>
        </article>

        <hr />

        
<div style="display: grid; grid-template-columns: 2% 49% 49%; text-align: center;">
  <div class="submenu" style="background: transparent; text-align: left; position: relative;">
    <li class="dropdown" onmouseover="menuDisplay(this.children[1], true);" onmouseout="menuDisplay(this.children[1], false);">
      <a class="dropbtn" href=""><i class="fa-solid fa-angles-up"></i></a>
      <div class="dropdown-content" style="bottom: 100%;"><a class="post-item-inner" href="https://doc.sireum.org/volumes/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Volumes</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Logika</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/courses/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Course Materials</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/courses/software-correctness/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Logika Course: Software Correctness</a><a class="post-item-inner" href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics-old/" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">Basic Principles (old)</a></div>
    </li>
  </div>
  <div style="text-align: left;">
    
      <a href="https://doc.sireum.org/volumes/logika/courses/software-correctness/basics-old/correctness-verification/" style="text-decoration: none;" onmouseover="menuUnderline(this, true);" onmouseout="menuUnderline(this, false);">
        <i class="fa-solid fa-chevron-left"></i> Software Correctness and Verification
      </a>
    
  </div>
  <div style="text-align: right;">
    
  </div>
</div>



        <div class="post-info">
            
            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin="anonymous"></script>



<script type="text/javascript" src="https://doc.sireum.org/bundle.min.d9847dec188cb3ba71e262769d7f64069d223c3a9713999a5da5f7aca5638686e15a900ac07cc755d19861961f24145ef2d608296933e4150cae87f4911a7dbb.js" integrity="sha512-2YR97BiMs7px4mJ2nX9kBp0iPDqXE5maXaX3rKVjhobhWpAKwHzHVdGYYZYfJBRe8tYIKWkz5BUMrof0kRp9uw=="></script>


<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/thecarnie-cycle2/2.1.6c/jquery.cycle2.min.js" integrity="sha512-ydWfQuPu+srw5hhkU8O1XGn3/Kc+GyoDBvYc8E+SyuZKphQP18ZWYKywIFzPWZwQk6dlmTY69aDg/SnFz3qPeQ==" crossorigin="anonymous"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/js/all.min.js" integrity="sha512-rpLlll167T5LJHwp0waJCh3ZRf7pO6IT1+LZOhAyP6phAirwchClbTZV3iqL3BMrVxIYRbzGTpli4rfxsCK6Vw==" crossorigin="anonymous"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.14/jstree.min.js" integrity="sha512-OQ2by9SrJBwcXaeYmkG2t6FVZiwpyRtFar2VvULjuq5OjVpJLwsUHuNzN9PClqEJAYsWsRPSb4TTfriZzPGiow==" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://doc.sireum.org/_pagefind/pagefind-ui.js"></script>
  <script type="text/javascript">
    window.addEventListener('DOMContentLoaded', (event) => {
      new PagefindUI({
        element: "#search",
        showEmptyFilters: true,
        mergeIndex: [
          
            { bundlePath: "https:\/\/sireum.org\/_pagefind" },
          
            { bundlePath: "https:\/\/slang.sireum.org\/_pagefind" },
          
            { bundlePath: "https:\/\/logika.sireum.org\/_pagefind" },
          
        ]
      });
    });
  </script>
<script style="text/javascript">
  window.addEventListener('load', function () {
    $('#page-tree').jstree({
      "core": {
        "themes": {
          "name": document.documentElement.getAttribute("data-theme") == "dark" ? "default-dark" : "default",
          "dots": true,
          "icons": false,
          "variant": "large"
        }
      },
      plugins: [ "ui" ],
    }).bind("select_node.jstree", function (e, data) {
      document.location.href = data.node.a_attr.href;
    }).bind("ready.jstree", function (event, data) {
      $(this).jstree("open_all");
    }).bind("open_all.jstree", function (event, data) {
      level = 0;
      data.instance.element.find('li').each(function() {
        if (level > 0 && data.instance.get_path(this).length >= level){
          data.instance.close_node(this);
        }
      });
      data.instance.element.get()[0].style.display="block";
    });
  });
</script>


    </body>
</html>
